{"meta":{"title":"Caffrey's Blog","subtitle":null,"description":null,"author":"Caffrey","url":"http://yoursite.com"},"pages":[{"title":"About me","date":"2017-03-04T16:00:00.000Z","updated":"2017-09-04T03:57:50.991Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我Caffrey /凯fu瑞/ 嫌麻烦的也可以直接喊 NealCode，Game，Music.失去任何一项，我都觉得生活没有了意义。 To be is to do！活着就该奋斗！ 喜欢吃，即便有时候很累，也不会委屈自己身体。每天都会自己准备好吃的午饭，偶尔还会创新个新菜。 这里有我的踪迹主页：https://qiaobox.github.io/ Mail：&#x63;&#105;&#116;&#x79;&#101;&#x79;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d; Location：深圳 友情链接请联系企鹅：2233572998"},{"title":"gallery","date":"2017-08-02T05:38:51.921Z","updated":"2017-08-02T05:38:51.885Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"__proto__与constructor","slug":"prototype","date":"2017-07-03T16:00:00.000Z","updated":"2017-09-05T01:11:03.673Z","comments":true,"path":"2017/07/04/prototype/","link":"","permalink":"http://yoursite.com/2017/07/04/prototype/","excerpt":"","text":"proto(前后跟标题一样都有下划线) 通过该属性可以允许实例对象直接访问原型123456789function Person()&#123; //这里的Person.prototype我们称为神秘对象 //只有通过构造函数才可以访问它 var o = new Person(); //以前o不能直接访问神秘对象 //现在有了__proto__ //o.__proto__可以直接访问神秘对象 //o.__proto__ === Person.prototype&#125; proto(前后跟标题一样都有下划线) 可以访问原型。 在开发中除非特殊要求,不要使用实例去修改原型的成员,因此该属性开发使用少。 但是在调试过程中使用非常方便,可以轻易的访问原型进行查看成员。 constructor prototype中都有一个属性’constructor’,译为构造器,表示该原型是与什么构造函数联系起来,简单来说就是神秘对象通过该属性访问到构造函数。 使用点语法给原型添加成员与直接使用替换修改原型对象的区别： 1.原型指向发生了变化2.构造函数所创建的对象所继承的原型不同3.新增的对象默认没有constructor属性 注意：在使用替换方式修改原型的时候,一般都会添加constructor属性 1234function Person()&#123;&#125;Person.prototype = &#123; constructor: Person;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"原型","slug":"原型","permalink":"http://yoursite.com/tags/原型/"}]},{"title":"移动web知识总结","slug":"mobile web","date":"2017-06-13T16:00:00.000Z","updated":"2017-09-05T01:11:20.129Z","comments":true,"path":"2017/06/14/mobile web/","link":"","permalink":"http://yoursite.com/2017/06/14/mobile web/","excerpt":"","text":"很多同学往往只是会用一些东西，而忽视了它的概念及原理 Pixelpx：CSS pixels 逻辑像素，浏览器使用的抽象单位 dp,pt：device independent pixels 设备无关像素 dpr：devicePixelRatio 设备像素缩放比 计算公式：1px = (dpr)² * dp 为什么iPhone5是 320px * 568px ？ 因为 dpr = 2 平面上：1px = (2)² * dp 纬度上：1px = 2 dp 所以，640dp 1136dp = 320px * 568px DPI：打印机每英寸可以喷的墨汁点(印刷行业) PPI：屏幕每英寸的像素数量，即单位英寸内的像素密度 目前，在计算机显示设备参数描述上，二者表达的意思是一样的。 计算公式：以iPhone5为例ppi = √(1136² + 640²) / 4 = 326ppi (视网膜Retina屏)ppi越高，像素数越高，图像越清晰 ldpi mdpi hdpi xhdpi ppi 120 160 240 320 默认缩放比 0.75 1.0 1.5 2.0 Retina屏(高清屏)：dpr都是大于等于2 以iphone5为例子 设备分辨率1136*640dp =&gt; √(1136² + 640²) / 4 = 326ppi =&gt; 326ppi属于retina屏幕，dpr = 2 1px = dpr² dp =&gt; iphone5的屏幕为 320 568px Viewport手机浏览器默认为我们做了两件事却 一：页面渲染在一个980px(ios)的viewport 二：缩放 为什么不用默认980px的布局viewport开发？ 宽度不可控制，不同系统不同设备默认值都可能不同 页面缩小版显示，交互不友好 链接不可点 有缩放，缩放后又有滚动 总体来说就是不规范 Viewport meta标签1&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot;&gt; width:设置布局viewport的特定值(device-width) initial-scale: 设置页面的初始缩放 minimum-scale：最少缩放 maximum-scale：最大缩放 user-scalable：用户能否缩放 document.body.clientWidth 获取页面布局viewportwindow.innerWidth 获取页面度量viewport 移动web最佳viewport设置[布局viewport] = [设备宽度] = [度量viewport] 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"基本概念","slug":"基本概念","permalink":"http://yoursite.com/tags/基本概念/"}]},{"title":"Flex弹性盒模型","slug":"flex","date":"2017-05-10T16:00:00.000Z","updated":"2017-09-05T01:10:03.859Z","comments":true,"path":"2017/05/11/flex/","link":"","permalink":"http://yoursite.com/2017/05/11/flex/","excerpt":"","text":"flex布局在很多移动端项目中使用，下面介绍flex布局的基本用法 body{ font-family: &apos;微软雅黑&apos;; padding: 0; margin: 20px 0 40px; font-size: 16px; background-color: #f9f9f9; } h2{ color: #0BF; text-indent: 15px; } h3{ color: #6d7273; text-indent: 15px; padding: 10px 0; background-color: #fff; } .flex_block{ display: -webkit-flex; } #post-content .flex_block p{ line-height: 20px; font-size: 14px; margin:0; } .flex_box{ max-width: 600px; padding: 20px; box-shadow: 0 6px 15px rgba(36,37,38,0.08); overflow: hidden; margin: 10px 15px; } .flex_item{ margin-top: 20px; display: -webkit-flex; } .flex_item.flex_border{ border: 1px dashed #888888; } .flex_item.flex_direction_r{ flex-direction: row-reverse; } .flex_item.flex_direction_cl{ flex-direction: column; height: 200px; } .flex_item.flex_direction_clr{ flex-direction: column-reverse; height: 200px; } .flex_item.flex_wrap{ flex-wrap: wrap; border: 1px dashed #888888; } .flex_item.flex_end{ justify-content: flex-end; } .flex_item.flex_center{ justify-content: center; } .flex_item.flex_between{ justify-content: space-between; } .flex_item.flex_around{ justify-content: space-around; } .flex_item.items_start{ align-items: flex-start; } .flex_item.items_end{ align-items: flex-end; } .flex_item.items_center{ align-items: center; } .flex_item .self_start{ align-self: flex-start; } .flex_item .self_end{ align-self: flex-end; } .flex_item .self_center{ align-self: center; } .flex_item .order{ order: -1; } .flex_list { background-color: #bbbbbb; line-height: 0px !important; } .flex_list p{ line-height: 20px; color: #fff; text-align: center; margin: 0; padding: 15px 0px; } .flex_list:nth-of-type(1){ background-color: #ffb199; } .flex_list:nth-of-type(2){ background-color: #8fd3f4; } .flex_list:nth-of-type(3){ background-color: #b490ca; } .flex_1{ flex: 1; } .flex_2{ flex: 2; } .flex_3{ flex: 3; } .flex_wd100{ width: 100px; } .flex_wd150{ width: 150px; } .flex_wd200{ width: 200px; } .flex_wd300{ width: 300px; } .flex_ht50{ height: 50px; } .flex_ht100{ height: 100px; } .flex_ht150{ height: 150px; } .flex_ht200{ height: 200px; } .flex_mr{ margin-right: 10px; } .flex_ml{ margin-left: 10px; } .wd400{ width: 400px; } @media (max-width: 768px){ .flex_block{ flex-direction: column; } } [flex] display:-webkit-flex; width:100px; flex:1; flex:2; display:-webkit-flex; width:150px;margin-right:10px; flex:1; width:150px;margin-left:10px; [flex-direction] flex-dection:row /default/display:-webkit-flex; flex:1; flex:2; flex:3; flex-dection:row-reverse;display:-webkit-flex; flex:1; flex:2; flex:3; flex-dection:column;display:-webkit-flex; flex:1; flex:2; flex:3; flex-dection:column-reverse;display:-webkit-flex; flex:1; flex:2; flex:3; [flex-wrap] flex-dection:no-wrap /default/display:-webkit-flex; width:100px; width:200px; width:300px; flex-dection:row-reverse;display:-webkit-flex; width:100px; width:200px; width:300px; [justify-content] justify-content:flex-start;/default/display:-webkit-flex; width:100px; width:100px; justify-content:flex-end;display:-webkit-flex; width:100px; width:100px; justify-content:flex-center;display:-webkit-flex; width:100px; width:100px; justify-content:space-between;display:-webkit-flex; width:100px; width:100px; justify-content:space-around;display:-webkit-flex; width:100px; width:100px; [align-self] display:-webkit-flex; align-self:flex-start; align-self:flex-end; align-self:flex-center; [align-items] align-items:flex_start;/default/display:-webkit-flex; width:100px; width:100px; align-items:flex_end;display:-webkit-flex; width:100px; width:100px; align-items:flex_center;/default/display:-webkit-flex; width:100px; width:100px; [order] display:-webkit-flex; a b c d e f","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"gulp","slug":"archives1","date":"2017-04-08T16:00:00.000Z","updated":"2017-09-05T01:53:35.994Z","comments":true,"path":"2017/04/09/archives1/","link":"","permalink":"http://yoursite.com/2017/04/09/archives1/","excerpt":"","text":"gulp-task gulp.task通过该方法创建一个新的任务 123gulp.task(&apos;hello&apos;,function()&#123; console.log(&apos;您好&apos;);&#125;) 然后在控制台输入 gulp hello就可以执行任务默认执行可以创建一个默认任务1gulp.task(&apos;default&apos;,[&apos;hello&apos;]); gulp-basic gulp.src()获取到要处理的文件, .pipe()处理获取到的文件, .pipe(gulp.dest())把处理好的文件放到指定地方。 gulp-copy 创建一个images任务,把images目录的下的jpg后缀文件拷贝到dist/images目录下(不包含images下目录中的文件) 12345gulp.task(&apos;images&apos;, function()&#123; return gulp.src(&apos;images/*.jpg&apos;) .pipe(gulp.dest(&apos;dist/images&apos;)) .pipe(content.reload()); /*复制完以后自动刷新页面*/&#125;); 如果想从多个文件中复制出来图片文件，再放到同一个目录dist/images下可以这样写 gulp.task(&apos;images&apos;, function(){ return gulp.src([&apos;images/*.jpg&apos;, &apos;img/*.jpg&apos;, &apos;!img/secret-*.jpg&apos;]).pipe(gulp.dest(&apos;dist/images&apos;)); }); 这种情况不仅限于图片，还可以复制多个文件到某一个文件夹下,src最后一个参数表明排除&apos;secret-&apos;开头的jpg文件，也就是不复制这种文件 想要把images下所有文件包含子目录下面的图片文件复制到dist/images目录下可以这样写 gulp.task(&apos;images&apos;, function(){ return gulp.src(&apos;images/**/*&apos;).pipe(gulp.dest(&apos;dist/images&apos;)); }); gulp-build 默认执行设置的任务，再执行本任务 gulp.task(&apos;build&apos;,[&apos;images&apos;, &apos;hello&apos;], function(){ console.log(&apos;编译成功!&apos;); }) gulp-watch 监听某个文件的变化，当文件发生变化，去执行设置的任务 假设我们创建了一个index.html文件,执行监听任务 gulp.task(&apos;watch&apos;, function(){ gulp.watch(&apos;index.html&apos;, [&apos;copy&apos;]); gulp.watch(&apos;images/**/*&apos;, [&apos;images&apos;]); }) gulp-plugin gulp的插件,可以在 gulp插件 搜索 如果我们要用sass插件,首先需要npm install sass --save 安装插件,然后在页面头部引用 var sass = require(&apos;gulp-sass&apos;) gulp.task(&apos;sass&apos;, function(){ return gulp.src(&apos;stylesheets/**/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;)); }) 同样的，如果需要用到content插件(起一个本地服务器),先安装，再在头部引用 var content = require(&apos;gulp-content&apos;) gulp.task(&apos;server&apos;, function(){ content.server({ root: &apos;dist&apos;, /*启动服务的根目录*/ port: 8090, /*设置端口*/ livereload: true /*自动刷新*/ }); }); 创建一个默认任务,起一个服务，在页面修改的时候自动刷新页面 gulp.task(&apos;default&apos;, [&apos;server&apos;, &apos;watch&apos;]) gulp-concat gulp的一个插件,可以使用concat这个插件合并文件 gulp.task(&apos;script&apos;, function(){ return gulp.src([&apos;javascript/jquery.js&apos;, &apos;javascript/calander.js&apos;]) .pipe(contact(&apos;mix.js&apos;)) .pipe(gulp.dest(&apos;dist/js&apos;)); }) gulp-uglify gulp的一个插件,可以使用uglify来压缩文件这个插件不用单独创建任务,可以在合并文件之后,直接执行压缩文件的方法 gulp.task(&apos;script&apos;, function(){ return gulp.src([&apos;javascript/jquery.js&apos;, &apos;javascript/calander.js&apos;]) .pipe(contact(&apos;mix.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js&apos;)); }) gulp-rename gulp的一个插件,如果想保留原有的js和压缩后的js两个文件,可以在压缩后重命名文件，再保存 gulp.task(&apos;script&apos;, function(){ return gulp.src([&apos;javascript/jquery.js&apos;, &apos;javascript/calander.js&apos;]) .pipe(contact(&apos;mix.js&apos;)) .pipe(gulp.dest(&apos;dist/js&apos;)) .pipe(uglify()) .pipe(rename(&apos;mix.min.js&apos;)) .pipe(gulp.dest(&apos;dist/js&apos;)); }) gulp-minifycss gulp的一个插件,压缩css的尺寸,同样的可以压缩css文件的大小,可以参考对js的操作重命名css另外保存 gulp.task(&apos;sass&apos;, function(){ return gulp.src(&apos;stylesheets/**/*.scss&apos;) .pipe(sass()) .pipe(minifycss()) .pipe(gulp.dest(&apos;dist/css&apos;)); }) gulp-imagemin gulp.task(&apos;images&apos;, function(){ return gulp.src(&apos;images/*.jpg&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;)) .pipe(content.reload()); /*复制完以后自动刷新页面*/ });","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]}]}